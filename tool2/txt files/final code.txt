----------------------------------------------------------------
ast_generator.py:
----------------------------------------------------------------




import json
from antlr4 import *
from antlr.TSqlLexer import TSqlLexer
from antlr.TSqlParser import TSqlParser
from antlr.TSqlParserVisitor import TSqlParserVisitor
from antlr4.tree.Tree import TerminalNodeImpl

class ASTBuilder(TSqlParserVisitor):
    def __init__(self):
        self.asts = []
        self.current_ast = None
        self.statement_stack = []
        self.cursors = []

    def get_full_text(self, ctx):
        if not ctx:
            return ""
        try:
            return ctx.start.getInputStream().getText(ctx.start.start, ctx.stop.stop)
        except Exception:
            return ctx.getText()

    def _add_statement(self, stmt_object):
        # Fix incorrect cursor field name
        if "name" in stmt_object and stmt_object["type"].endswith("_CURSOR"):
            stmt_object["cursor_name"] = stmt_object.pop("name")
        
        if self.statement_stack:
            self.statement_stack[-1].append(stmt_object)
        else:
            self.current_ast["statements"].append(stmt_object)

    def _get_procedure_name(self, ctx):
        candidates = [
            'func_proc_name_schema',
            'full_object_name',
            'func_proc_name',
            'procedure_name',
            'func_proc_name_server_database_schema'
        ]
        for name in candidates:
            if hasattr(ctx, name) and getattr(ctx, name)():
                return self.get_full_text(getattr(ctx, name)())
        return "<unknown>"

    def visitTsql_file(self, ctx):
        self.visitChildren(ctx)
        return self.asts

    def visitBatch(self, ctx):
        return self.visitChildren(ctx)

    def visitCreate_or_alter_procedure(self, ctx: TSqlParser.Create_or_alter_procedureContext):
        self.current_ast = {
            "proc_name": self._get_procedure_name(ctx),
            "params": [],
            "return_type": "INTEGER",
            "cursors": [],
            "variables": [],
            "statements": []
        }
        self.asts.append(self.current_ast)

        self.statement_stack.append(self.current_ast["statements"])
        self.visitChildren(ctx)
        self.statement_stack.pop()

        self.current_ast["cursors"].extend(self.cursors)
        self.cursors.clear() 

    def visitProcedure_param(self, ctx: TSqlParser.Procedure_paramContext):
        param = {
            "name": self.get_full_text(ctx.LOCAL_ID()),
            "type": self.get_full_text(ctx.data_type()),
            "mode": "OUT" if ctx.OUTPUT() or ctx.OUT() else "IN"
        }
        self.current_ast["params"].append(param)

    def visitDeclare_statement(self, ctx):
        # CHANGE 2: Ensure both variable and cursor declarations are processed.
        # This is a necessary fix to make sure visitDeclare_cursor is called.
        if hasattr(ctx, 'declare_local') and ctx.declare_local():
            for decl in ctx.declare_local():
                self.current_ast["variables"].append({
                    "name": self.get_full_text(decl.LOCAL_ID()),
                    "type": self.get_full_text(decl.data_type())
                })
        
        if hasattr(ctx, 'declare_cursor') and ctx.declare_cursor():
            for cursor_decl in ctx.declare_cursor():
                self.visit(cursor_decl)


    def visitSet_statement(self, ctx):
        stmt = {"type": "SET"}
        if ctx.LOCAL_ID():
            stmt["name"] = self.get_full_text(ctx.LOCAL_ID())
            stmt["value"] = self.get_full_text(ctx.expression())
        else:
            stmt["expression"] = self.get_full_text(ctx)
        self._add_statement(stmt)

    def visitSelect_statement(self, ctx):
        stmt = {"type": "SELECT", "query": self.get_full_text(ctx)}
        self._add_statement(stmt)

    def visitUpdate_statement(self, ctx):
        stmt = {
            "type": "UPDATE",
            "table": self.get_full_text(ctx.ddl_object()),
            "set": {},
            "where": self.get_full_text(ctx.search_condition()) if ctx.search_condition() else ""
        }
        for elem in ctx.update_elem():
            stmt["set"][self.get_full_text(elem.full_column_name())] = self.get_full_text(elem.expression())
        self._add_statement(stmt)

    def visitReturn_statement(self, ctx):
        stmt = {"type": "RETURN", "value": self.get_full_text(ctx.expression()) if ctx.expression() else "0"}
        self._add_statement(stmt)

    def visitIf_statement(self, ctx):
        stmt = {
            "type": "IF",
            "condition": self.get_full_text(ctx.search_condition()),
            "then": [],
            "else": []
        }
        self._add_statement(stmt)

        self.statement_stack.append(stmt["then"])
        if ctx.sql_clauses(0):
            self.visit(ctx.sql_clauses(0))
        self.statement_stack.pop()

        if ctx.sql_clauses(1):
            self.statement_stack.append(stmt["else"])
            self.visit(ctx.sql_clauses(1))
            self.statement_stack.pop()
        else:
            del stmt["else"]

    def visitWhile_statement(self, ctx):
        stmt = {
            "type": "WHILE",
            "condition": self.get_full_text(ctx.search_condition()),
            "body": []
        }
        self._add_statement(stmt)
        self.statement_stack.append(stmt["body"])
        self.visit(ctx.sql_clauses())
        self.statement_stack.pop()

    def visitTry_catch_statement(self, ctx):
        stmt = {
            "type": "TRY_CATCH",
            "try": [],
            "catch": []
        }
        self._add_statement(stmt)

        self.statement_stack.append(stmt["try"])
        self.visit(ctx.sql_clauses(0))
        self.statement_stack.pop()

        self.statement_stack.append(stmt["catch"])
        self.visit(ctx.sql_clauses(1))
        self.statement_stack.pop()

    def visitExecute_statement(self, ctx):
        stmt = {"type": "EXEC", "command": self.get_full_text(ctx)}
        self._add_statement(stmt)

    def visitBegin_transaction(self, ctx):
        self._add_statement({"type": "BEGIN_TRANSACTION"})

    def visitCommit_transaction(self, ctx):
        self._add_statement({"type": "COMMIT_TRANSACTION"})

    def visitRollback_transaction(self, ctx):
        self._add_statement({"type": "ROLLBACK_TRANSACTION"})

    def visitClose_cursor(self, ctx):
        # This implementation uses cursor_name() which is more robust if available in grammar
        cursor_name = self.get_full_text(ctx.cursor_name()) if ctx.cursor_name() else self.get_full_text(ctx.LOCAL_ID())
        # print(f"🧭 DEBUG: Visiting CLOSE_CURSOR: {cursor_name}")
        self._add_statement({"type": "CLOSE_CURSOR", "cursor_name": cursor_name})
        # stmt = {"type": "CLOSE_CURSOR", "cursor": cursor_name}
        # self._add_statement(stmt)

    def visitDeallocate_cursor(self, ctx):
        cursor_name = self.get_full_text(ctx.cursor_name()) if ctx.cursor_name() else self.get_full_text(ctx.LOCAL_ID())
        # print(f"🧭 DEBUG: Visiting DEALLOCATE_CURSOR: {cursor_name}")
        # stmt = {"type": "DEALLOCATE_CURSOR", "cursor": cursor_name}
        self._add_statement({"type": "DEALLOCATE_CURSOR", "cursor_name": cursor_name})

    def visitOpen_cursor(self, ctx):
        cursor_name = self.get_full_text(ctx.cursor_name()) if hasattr(ctx, 'cursor_name') else self.get_full_text(ctx.LOCAL_ID())
        # print(f"🧭 DEBUG: OPEN_CURSOR for {cursor_name}")
        # stmt = {"type": "OPEN_CURSOR", "cursor": cursor_name}
        self._add_statement({"type": "OPEN_CURSOR", "cursor_name": cursor_name})

    def visitFetch_cursor(self, ctx):
        # Assumes grammar has cursor_name() and multiple LOCAL_ID() for the INTO clause
        cursor_name = self.get_full_text(ctx.cursor_name())
        fetch_into = [self.get_full_text(id) for id in ctx.LOCAL_ID()] if ctx.LOCAL_ID() else []
        # print(f"🧭 DEBUG: Visiting FETCH_CURSOR: {cursor_name}, into: {fetch_into}")
        into_vars = [self.get_full_text(id_) for id_ in ctx.LOCAL_ID()]
        if not hasattr(ctx, 'cursor_name') and into_vars:
            into_vars = into_vars[1:]

        self._add_statement({"type": "FETCH_CURSOR", "cursor_name": cursor_name, "fetch_into": fetch_into})

    def visitDeclare_cursor(self, ctx):
        # print("🧭 DEBUG: Visiting DECLARE CURSOR...")

        cursor_name = "<unknown>"

        try:
            if hasattr(ctx, 'cursor_name') and ctx.cursor_name():
                cursor_name = self.get_full_text(ctx.cursor_name())
                print(f"✅ DEBUG: Found cursor_name via cursor_name(): {cursor_name}")
            elif ctx.LOCAL_ID():
                cursor_name = self.get_full_text(ctx.LOCAL_ID(0))
                print(f"✅ DEBUG: Found cursor_name via LOCAL_ID(0): {cursor_name}")
            else:
                for child in ctx.children:
                    if hasattr(child, 'getText') and child.getText().startswith('@'):
                        cursor_name = child.getText()
                        print(f"✅ DEBUG: Found cursor_name via children: {cursor_name}")
                        break

            # Try to extract the SELECT statement
            select_ctx = None
            if hasattr(ctx, 'select_statement') and ctx.select_statement():
                select_ctx = ctx.select_statement()
                print("✅ DEBUG: Found SELECT statement via select_statement()")
            else:
                for child in ctx.children:
                    if isinstance(child, TSqlParser.Select_statementContext):
                        select_ctx = child
                        print("✅ DEBUG: Found SELECT statement via child loop")
                        break

            query = self.get_full_text(select_ctx) if select_ctx else "<missing_query>"

            cursor_info = {
                "name": cursor_name,
                "query": query
            }

            print(f"📌 DEBUG: Final cursor_info = {cursor_info}")

            # Append to self.cursors list, not self.current_ast
            self.cursors.append(cursor_info)

        except Exception as e:
            print(f"❌ ERROR while parsing DECLARE CURSOR: {e}")

    def visitRaiseerror_statement(self, ctx):
        stmt = {
            "type": "RAISERROR",
            "message": None,
            "severity": None,
            "state": None,
            "args": [],
            "options": []
        }

        if ctx.getChildCount() == 0:
            return stmt

        try:
            tokens = [self.get_full_text(c) for c in ctx.children]
            print("DEBUG: RAISERROR tokens:", tokens)

            first_token = ctx.getChild(0).getText().upper()

            if first_token == "RAISERROR":
                if ctx.getChildCount() == 2 and ctx.getChild(1).getText().startswith("'"):
                    # Sybase-style: RAISERROR 'message'
                    stmt["message"] = ctx.getChild(1).getText()
                elif ctx.getChild(1).getText() == '(':  
                    # SQL Server style: RAISERROR (msg, severity, state [, args...])
                    message_token = ctx.getChild(2)
                    severity_token = ctx.getChild(4)
                    state_token = ctx.getChild(6)

                    stmt["message"] = self.get_full_text(message_token)
                    stmt["severity"] = self.get_full_text(severity_token)
                    stmt["state"] = self.get_full_text(state_token)

                    # Optional args
                    if ctx.getChildCount() >= 9:
                        i = 8
                        while i < ctx.getChildCount() and ctx.getChild(i).getText() != ')':
                            if ctx.getChild(i).getText() == ',':
                                arg_token = ctx.getChild(i + 1)
                                stmt["args"].append(self.get_full_text(arg_token))
                                i += 2
                            else:
                                i += 1

                    if "WITH" in tokens:
                        idx = tokens.index("WITH")
                        stmt["options"] = tokens[idx + 1:]
                else:
                    # Possibly severity + message form: RAISERROR severity 'message'
                    stmt["message"] = ctx.getChild(2).getText() if ctx.getChildCount() >= 3 else "<missing>"
                    if ctx.argument():
                        stmt["args"] = [self.get_full_text(arg) for arg in ctx.argument()]
        except Exception as e:
            print(f"❌ Error parsing RAISERROR: {e}")
            stmt["message"] = "<parse_error>"

        self._add_statement(stmt)



    def visitSql_clauses(self, ctx):
        sql_text = self.get_full_text(ctx).strip()
        # print("🔍 DEBUG: SQL Text =", sql_text)

        # Match cursor operations manually
        if sql_text.upper().startswith("OPEN "):
            cursor_name = sql_text.split()[1]
            # print(f"🔍 DEBUG: Found OPEN_CURSOR for {cursor_name}")
            self.current_ast["statements"].append({
                "type": "OPEN_CURSOR",
                "cursor_name": cursor_name
            })

        elif sql_text.upper().startswith("FETCH NEXT FROM"):
            tokens = sql_text.replace(",", " ").split()
            try:
                cursor_name_idx = tokens.index("FROM") + 1
                cursor_name = tokens[cursor_name_idx]
                into_idx = tokens.index("INTO") + 1
                fetch_into = tokens[into_idx:]
                # print(f"🔍 DEBUG: Found FETCH_CURSOR for {cursor_name} INTO {fetch_into}")
                self.current_ast["statements"].append({
                    "type": "FETCH_CURSOR",
                    "cursor_name": cursor_name,
                    "fetch_into": fetch_into
                })
            except Exception as e:
                print(f"❌ ERROR parsing FETCH_CURSOR: {e}")

        elif sql_text.upper().startswith("CLOSE "):
            cursor_name = sql_text.split()[1]
            # print(f"🔍 DEBUG: Found CLOSE_CURSOR for {cursor_name}")
            self.current_ast["statements"].append({
                "type": "CLOSE_CURSOR",
                "cursor_name": cursor_name
            })

        elif sql_text.upper().startswith("DEALLOCATE "):
            cursor_name = sql_text.split()[1]
            # print(f"🔍 DEBUG: Found DEALLOCATE_CURSOR for {cursor_name}")
            self.current_ast["statements"].append({
                "type": "DEALLOCATE_CURSOR",
                "cursor_name": cursor_name
            })

        else:
            # Fallback to the default visitor for other statements
            self.visitChildren(ctx)

# --- Top-level Execution ---

def generate_ast(sql_file_path: str) -> list:
    with open(sql_file_path, "r") as f:
        input_sql = f.read()

    input_stream = InputStream(input_sql)
    lexer = TSqlLexer(input_stream)
    token_stream = CommonTokenStream(lexer)
    parser = TSqlParser(token_stream)
    tree = parser.tsql_file()

    visitor = ASTBuilder()
    asts = visitor.visit(tree)

    if not asts:
        print("❌ No procedure AST found.")
    else:
        print(f"✅ {len(asts)} procedure(s) parsed.")

    return asts

def save_ast(asts: list, output_path: str):
    print(f"📝 Writing ASTs to {output_path}")
    with open(output_path, "w") as f:
        json.dump(asts, f, indent=4)




----------------------------------------------------------------
main.py:
----------------------------------------------------------------
# main.py

import sys
from ast_generator import generate_ast, save_ast
from validator import validate_ast  # ✅ Import validator

def main():
    """
    Main function to run the AST generator from the command line.
    """
    if len(sys.argv) != 3:
        print("Usage: python main.py <input_sql_file> <output_json_file>")
        sys.exit(1)

    input_file = sys.argv[1]
    output_file = sys.argv[2]

    print(f"🚀 Starting AST generation for: {input_file}")

    try:
        print("📥 Reading input SQL file...")
        ast = generate_ast(input_file)

        if ast is None:
            print("❌ AST generation failed — returned None.")
            sys.exit(1)

        print(f"📤 Saving AST to file: {output_file}")
        save_ast(ast, output_file)
        print(f"✅ AST successfully saved to {output_file}")

        # ✅ Validate the AST
        schema_file = "schema/ast_schema.json"  # Update if in another path
        print(f"🧪 Validating AST against schema: {schema_file}")
        validate_ast(output_file, schema_file)

    except Exception as e:
        print(f"❌ An unexpected error occurred during processing:\n{e}")
        sys.exit(1)

if __name__ == "__main__":
    main()





----------------------------------------------------------------
validator.py
----------------------------------------------------------------



# validator.py

import json
import sys
from jsonschema import validate, ValidationError

def validate_ast(ast_path, schema_path):
    print(f"📂 Loading AST file: {ast_path}")
    with open(ast_path, 'r') as ast_file:
        ast = json.load(ast_file)

    print(f"📂 Loading Schema file: {schema_path}")
    with open(schema_path, 'r') as schema_file:
        schema = json.load(schema_file)

    print("🔍 Starting schema validation...")

    try:
        validate(instance=ast, schema=schema)
        print("✅ AST is valid according to the schema.")
    except ValidationError as e:
        print("❌ AST validation failed.")
        print(f"📌 Error Message: {e.message}")
        print(f"📍 AST Path: {'/'.join(str(p) for p in e.path)}")
        print(f"📍 Schema Path: {'/'.join(str(p) for p in e.schema_path)}")
        sys.exit(1)
