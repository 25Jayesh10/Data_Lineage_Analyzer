import json
from antlr4 import *
from antlr.TSqlLexer import TSqlLexer
from antlr.TSqlParser import TSqlParser
from antlr.TSqlParserVisitor import TSqlParserVisitor
from antlr4.tree.Tree import TerminalNodeImpl

class ASTBuilder(TSqlParserVisitor):
    def __init__(self):
        self.asts = []
        self.current_ast = None
        self.statement_stack = []

    def get_full_text(self, ctx):
        if not ctx:
            return ""
        try:
            return ctx.start.getInputStream().getText(ctx.start.start, ctx.stop.stop)
        except Exception:
            return ctx.getText()

    def _add_statement(self, stmt_object):
        if self.statement_stack:
            self.statement_stack[-1].append(stmt_object)

    def _get_procedure_name(self, ctx):
        candidates = [
            'func_proc_name_schema',
            'full_object_name',
            'func_proc_name',
            'procedure_name',
            'func_proc_name_server_database_schema'
        ]
        for name in candidates:
            if hasattr(ctx, name) and getattr(ctx, name)():
                return self.get_full_text(getattr(ctx, name)())
        return "<unknown>"

    def visitTsql_file(self, ctx):
        self.visitChildren(ctx)
        return self.asts

    def visitBatch(self, ctx):
        return self.visitChildren(ctx)

    def visitCreate_or_alter_procedure(self, ctx: TSqlParser.Create_or_alter_procedureContext):
        self.current_ast = {
            "proc_name": self._get_procedure_name(ctx),
            "params": [],
            "return_type": "INTEGER",
            "variables": [],
            "statements": []
        }
        self.asts.append(self.current_ast)

        self.statement_stack.append(self.current_ast["statements"])
        self.visitChildren(ctx)
        self.statement_stack.pop()

    def visitProcedure_param(self, ctx: TSqlParser.Procedure_paramContext):
        param = {
            "name": self.get_full_text(ctx.LOCAL_ID()),
            "type": self.get_full_text(ctx.data_type()),
            "mode": "OUT" if ctx.OUTPUT() or ctx.OUT() else "IN"
        }
        self.current_ast["params"].append(param)

    def visitDeclare_statement(self, ctx):
        # CHANGE 2: Ensure both variable and cursor declarations are processed.
        # This is a necessary fix to make sure visitDeclare_cursor is called.
        if hasattr(ctx, 'declare_local') and ctx.declare_local():
            for decl in ctx.declare_local():
                self.current_ast["variables"].append({
                    "name": self.get_full_text(decl.LOCAL_ID()),
                    "type": self.get_full_text(decl.data_type())
                })
        
        if hasattr(ctx, 'declare_cursor') and ctx.declare_cursor():
            for cursor_decl in ctx.declare_cursor():
                self.visit(cursor_decl)


    def visitSet_statement(self, ctx):
        stmt = {"type": "SET"}
        if ctx.LOCAL_ID():
            stmt["name"] = self.get_full_text(ctx.LOCAL_ID())
            stmt["value"] = self.get_full_text(ctx.expression())
        else:
            stmt["expression"] = self.get_full_text(ctx)
        self._add_statement(stmt)

    def visitSelect_statement(self, ctx):
        stmt = {"type": "SELECT", "query": self.get_full_text(ctx)}
        self._add_statement(stmt)

    def visitUpdate_statement(self, ctx):
        stmt = {
            "type": "UPDATE",
            "table": self.get_full_text(ctx.ddl_object()),
            "set": {},
            "where": self.get_full_text(ctx.search_condition()) if ctx.search_condition() else ""
        }
        for elem in ctx.update_elem():
            stmt["set"][self.get_full_text(elem.full_column_name())] = self.get_full_text(elem.expression())
        self._add_statement(stmt)

    def visitReturn_statement(self, ctx):
        stmt = {"type": "RETURN", "value": self.get_full_text(ctx.expression()) if ctx.expression() else "0"}
        self._add_statement(stmt)

    def visitIf_statement(self, ctx):
        stmt = {
            "type": "IF",
            "condition": self.get_full_text(ctx.search_condition()),
            "then": [],
            "else": []
        }
        self._add_statement(stmt)

        self.statement_stack.append(stmt["then"])
        if ctx.sql_clauses(0):
            self.visit(ctx.sql_clauses(0))
        self.statement_stack.pop()

        if ctx.sql_clauses(1):
            self.statement_stack.append(stmt["else"])
            self.visit(ctx.sql_clauses(1))
            self.statement_stack.pop()
        else:
            del stmt["else"]

    def visitWhile_statement(self, ctx):
        stmt = {
            "type": "WHILE",
            "condition": self.get_full_text(ctx.search_condition()),
            "body": []
        }
        self._add_statement(stmt)
        self.statement_stack.append(stmt["body"])
        self.visit(ctx.sql_clauses())
        self.statement_stack.pop()

    def visitTry_catch_statement(self, ctx):
        stmt = {
            "type": "TRY_CATCH",
            "try": [],
            "catch": []
        }
        self._add_statement(stmt)

        self.statement_stack.append(stmt["try"])
        self.visit(ctx.sql_clauses(0))
        self.statement_stack.pop()

        self.statement_stack.append(stmt["catch"])
        self.visit(ctx.sql_clauses(1))
        self.statement_stack.pop()

    def visitExecute_statement(self, ctx):
        stmt = {"type": "EXEC", "command": self.get_full_text(ctx)}
        self._add_statement(stmt)

    def visitBegin_transaction(self, ctx):
        self._add_statement({"type": "BEGIN_TRANSACTION"})

    def visitCommit_transaction(self, ctx):
        self._add_statement({"type": "COMMIT_TRANSACTION"})

    def visitRollback_transaction(self, ctx):
        self._add_statement({"type": "ROLLBACK_TRANSACTION"})

    def visitClose_cursor(self, ctx):
        # This implementation uses cursor_name() which is more robust if available in grammar
        cursor_name = self.get_full_text(ctx.cursor_name()) if hasattr(ctx, 'cursor_name') else self.get_full_text(ctx.LOCAL_ID())
        stmt = {"type": "CLOSE_CURSOR", "cursor": cursor_name}
        self._add_statement(stmt)

    def visitDeallocate_cursor(self, ctx):
        cursor_name = self.get_full_text(ctx.cursor_name()) if hasattr(ctx, 'cursor_name') else self.get_full_text(ctx.LOCAL_ID())
        stmt = {"type": "DEALLOCATE_CURSOR", "cursor": cursor_name}
        self._add_statement(stmt)

    def visitOpen_cursor(self, ctx):
        cursor_name = self.get_full_text(ctx.cursor_name()) if hasattr(ctx, 'cursor_name') else self.get_full_text(ctx.LOCAL_ID())
        stmt = {"type": "OPEN_CURSOR", "cursor": cursor_name}
        self._add_statement(stmt)

    def visitFetch_cursor(self, ctx):
        # Assumes grammar has cursor_name() and multiple LOCAL_ID() for the INTO clause
        cursor_name = self.get_full_text(ctx.cursor_name()) if hasattr(ctx, 'cursor_name') else self.get_full_text(ctx.LOCAL_ID(0))
        into_vars = [self.get_full_text(id_) for id_ in ctx.LOCAL_ID()]
        # If cursor_name was derived from LOCAL_ID(0), remove it from into_vars
        # if self.get_full_text(ctx.cursor_name()) is None:
        #     into_vars.pop(0)
        if not hasattr(ctx, 'cursor_name') and into_vars:
            into_vars = into_vars[1:]

        stmt = {
            "type": "FETCH_CURSOR",
            "cursor": cursor_name,
            "into": into_vars
        }
        self._add_statement(stmt)

    def visitDeclare_cursor(self, ctx):
        # CHANGE 3: This now populates the 'cursors' list instead of the 'statements' list.
        cursor_name = "<unknown>"
        # Prefer using the named rule from the grammar if it exists
        if hasattr(ctx, 'cursor_name') and ctx.cursor_name():
            cursor_name = self.get_full_text(ctx.cursor_name())
        elif len(ctx.children) > 1:
            cursor_name = self.get_full_text(ctx.children[1])

        select_ctx = None
        # Prefer using the named rule from the grammar if it exists
        if hasattr(ctx, 'select_statement') and ctx.select_statement():
            select_ctx = ctx.select_statement()
        else: # Fallback to original logic
            for child in ctx.children:
                if isinstance(child, TSqlParser.Select_statementContext):
                    select_ctx = child
                    break
        
        stmt = {
            "type": "DECLARE_CURSOR",
            "cursor_name": cursor_name,
            "query": self.get_full_text(select_ctx) if select_ctx else "<missing_query>"
        }
        self._add_statement(stmt)
        # cursor_info = {
        #     "name": cursor_name,
        #     "query": self.get_full_text(select_ctx) if select_ctx else "<missing_query>"
        # }
        
        # if self.current_ast:
        #     self.current_ast["cursors"].append(cursor_info)
        
        # # NOTE: We no longer call _add_statement() here.

    def visitRaiseerror_statement(self, ctx):
        stmt = {
            "type": "RAISERROR",
            "message": None,
            "severity": None,
            "state": None,
            "args": [],
            "options": []
       }

        if ctx.RAISERROR():
            # Pattern: RAISERROR '(' msg, severity, state, [, arg, ...] ')'
            if ctx.getChild(1).getText() == '(':  # RAISERROR (...)
                children = ctx.children
                try:
                    msg_token = ctx.msg
                    stmt["message"] = self.get_full_text(msg_token)
                    stmt["severity"] = self.get_full_text(ctx.severity)
                    stmt["state"] = self.get_full_text(ctx.state)

                    # Optional additional args (after severity/state)
                    comma_indices = [i for i, c in enumerate(children) if c.getText() == ',']
                    if len(comma_indices) > 2:
                        extra_args_start = comma_indices[2] + 1
                        for i in range(extra_args_start, len(children)):
                            token = children[i]
                            if token.getText() in [')', 'WITH', ';']:
                                break
                            if token.getText() not in [',']:
                                stmt["args"].append(self.get_full_text(token))
                except Exception:
                    stmt["message"] = "<parse_error>"

            # Check for optional WITH (LOG | SETERROR | NOWAIT)
                if ctx.WITH():
                    for opt in ["LOG", "SETERROR", "NOWAIT"]:
                        if getattr(ctx, opt, None):
                                stmt["options"].append(opt)

            else:
                # Pattern: RAISERROR <decimal> <formatstring> [, arg, ...]
                stmt["message"] = self.get_full_text(ctx.formatstring)
                for arg in ctx.argument:
                    stmt["args"].append(self.get_full_text(arg))

        self._add_statement(stmt)

    def visitSql_clauses(self, ctx):
        return self.visitChildren(ctx)

    def visitSql_clause(self, ctx):
        return self.visitChildren(ctx)

# --- Top-level Execution ---

def generate_ast(sql_file_path: str) -> list:
    with open(sql_file_path, "r") as f:
        input_sql = f.read()

    input_stream = InputStream(input_sql)
    lexer = TSqlLexer(input_stream)
    token_stream = CommonTokenStream(lexer)
    parser = TSqlParser(token_stream)
    tree = parser.tsql_file()

    visitor = ASTBuilder()
    asts = visitor.visit(tree)

    if not asts:
        print("❌ No procedure AST found.")
    else:
        print(f"✅ {len(asts)} procedure(s) parsed.")

    return asts

def save_ast(asts: list, output_path: str):
    print(f"📝 Writing ASTs to {output_path}")
    with open(output_path, "w") as f:
        json.dump(asts, f, indent=4)