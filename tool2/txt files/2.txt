import json
from antlr4 import *
from antlr.TSqlLexer import TSqlLexer
from antlr.TSqlParser import TSqlParser
from antlr.TSqlParserVisitor import TSqlParserVisitor

class ASTBuilder(TSqlParserVisitor):
    def __init__(self):
        self.asts = []
        self.current_ast = None
        self.statement_stack = []

    def get_full_text(self, ctx):
        if not ctx:
            return ""
        try:
            # Use start/stop from the context to get the exact original text
            return ctx.start.getInputStream().getText(ctx.start.start, ctx.stop.stop)
        except Exception:
            # Fallback for nodes that might not have start/stop tokens
            return ctx.getText()

    def _add_statement(self, stmt_object):
        if self.statement_stack:
            print(f"üß± Adding statement: {stmt_object}")
            self.statement_stack[-1].append(stmt_object)

    def _get_procedure_name(self, ctx):
        candidates = [
            'func_proc_name_schema',
            'full_object_name',
            'func_proc_name',
            'procedure_name',
            'func_proc_name_server_database_schema'
        ]
        for name in candidates:
            if hasattr(ctx, name) and getattr(ctx, name)():
                return self.get_full_text(getattr(ctx, name)())
        return "<unknown>"
    
    # def _get_procedure_name(self, ctx):
    #     return ctx.func_proc_name_schema().id_()[0].getText()

    def _append_statement(self, stmt):
        if self.statement_stack:
            self.statement_stack[-1].append(stmt)

    def visitTsql_file(self, ctx):
        print("üîç Visiting TSQL file...")
        self.visitChildren(ctx)
        return self.asts

    def visitBatch(self, ctx):
        return self.visitChildren(ctx)

    def visitCreate_or_alter_procedure(self, ctx: TSqlParser.Create_or_alter_procedureContext):
        proc_name = self._get_procedure_name(ctx)
        print(f"üîß Processing procedure: {proc_name}")

        self.current_ast = {
            "proc_name": proc_name,
            "params": [],
            "return_type": "INTEGER",
            "variables": [],
            "statements": []
        }
        self.asts.append(self.current_ast)

        self.statement_stack.append(self.current_ast["statements"])

        clauses = ctx.sql_clauses()
        print(f"üîé ctx.sql_clauses() = {clauses}")
        if clauses:
            print(f"üîé Number of clause contexts: {len(clauses)}")
            for clause_ctx in clauses:
                print(f"üîπ clause_ctx text: {clause_ctx.getText()}")
                try:
                    self.visit(clause_ctx)
                except Exception as e:
                    print(f"‚ö†Ô∏è Error visiting sql_clauses: {type(clause_ctx)} - {e}")

        self.statement_stack.pop()


    def visitProcedure_param(self, ctx):
        param = {
            "name": self.get_full_text(ctx.LOCAL_ID()),
            "type": self.get_full_text(ctx.data_type()),
            "mode": "OUT" if ctx.OUTPUT() or ctx.OUT() else "IN"
        }
        self.current_ast["params"].append(param)

    def visitDeclare_statement(self, ctx: TSqlParser.Declare_statementContext):
        decls = ctx.declare_local()
        for decl in decls:
            var_name = decl.LOCAL_ID().getText()
            dtype = decl.data_type().getText()
            print(f"üìå Declaring variable: {var_name} of type {dtype}")
            self.current_ast["variables"].append({
                "name": var_name,
                "type": dtype
            })

    def visitSet_statement(self, ctx: TSqlParser.Set_statementContext):
        assignment = {
            "type": "SET",
            "target": ctx.LOCAL_ID().getText(),
            "value": ctx.expression().getText()
        }
        print(f"‚úèÔ∏è SET statement: {assignment}")
        self._append_statement(assignment)

    def visitSelect_statement_standalone(self, ctx):
        # This wrapper ensures we only process SELECTs that are actual statements
        self.visit(ctx.select_statement())
        return None

    def visitSelect_statement(self, ctx):
        stmt = {"type": "SELECT", "query": self.get_full_text(ctx)}
        self._add_statement(stmt)
        return None # Prevent re-visiting from other rules

    def visitUpdate_statement(self, ctx):
        stmt = {
            "type": "UPDATE",
            "table": self.get_full_text(ctx.ddl_object()),
            "set": {},
            "where": self.get_full_text(ctx.search_condition()) if ctx.where_clause() else ""
        }
        if ctx.update_elem():
            for elem in ctx.update_elem():
                col = self.get_full_text(elem.full_column_name())
                val = self.get_full_text(elem.expression())
                stmt["set"][col] = val
        self._add_statement(stmt)

    def visitReturn_statement(self, ctx: TSqlParser.Return_statementContext):
        ret_expr = ctx.expression().getText() if ctx.expression() else None
        stmt = {
            "type": "RETURN",
            "value": ret_expr
        }
        print(f"üîö RETURN statement: {stmt}")
        self._append_statement(stmt)

    def visitIf_statement(self, ctx: TSqlParser.If_statementContext):
        stmt = { "type": "IF", "condition": self.get_full_text(ctx.search_condition()), "then": [] }
        self._add_statement(stmt)

        self.statement_stack.append(stmt["then"])
        if ctx.sql_clauses():
            clauses = ctx.sql_clauses(0).sql_clause() if len(ctx.sql_clauses()) > 0 else []
            for clause in clauses:
                try:
                    self.visit(clause)
                except Exception as e:
                    print(f"‚ö†Ô∏è Error visiting IF-then clause: {type(clause)} - {e}")
        self.statement_stack.pop()

        if len(ctx.sql_clauses()) > 1:
            stmt["else"] = []
            self.statement_stack.append(stmt["else"])
            clauses = ctx.sql_clauses(1).sql_clause()
            for clause in clauses:
                try:
                    self.visit(clause)
                except Exception as e:
                    print(f"‚ö†Ô∏è Error visiting IF-else clause: {type(clause)} - {e}")
            self.statement_stack.pop()


    def visitWhile_statement(self, ctx: TSqlParser.While_statementContext):
        condition = ctx.search_condition().getText()
        print(f"üîÅ WHILE condition: {condition}")
        while_node = {
            "type": "WHILE",
            "condition": condition,
            "statements": []
        }
        self.statement_stack.append(while_node["statements"])
        self.visit(ctx.sql_clauses())
        self.statement_stack.pop()
        self._append_statement(while_node)

    
    def visitTry_catch_statement(self, ctx: TSqlParser.Try_catch_statementContext):
        stmt = { "type": "TRY_CATCH", "try": [], "catch": [] }
        self._add_statement(stmt)

        self.statement_stack.append(stmt["try"])
        if ctx.sql_clauses():
            for clause in ctx.sql_clauses(0).sql_clause():
                try:
                    self.visit(clause)
                except Exception as e:
                    print(f"‚ö†Ô∏è Error visiting TRY clause: {type(clause)} - {e}")
        self.statement_stack.pop()

        catch_object = { "exception": "ANY", "body": [] }
        stmt["catch"].append(catch_object)
        self.statement_stack.append(catch_object["body"])
        if len(ctx.sql_clauses()) > 1:
            for clause in ctx.sql_clauses(1).sql_clause():
                try:
                    self.visit(clause)
                except Exception as e:
                    print(f"‚ö†Ô∏è Error visiting CATCH clause: {type(clause)} - {e}")
        self.statement_stack.pop()

    def visitExecute_statement(self, ctx):
        stmt = {"type": "EXEC", "command": self.get_full_text(ctx)}
        self._add_statement(stmt)

    # CORRECTED: This method now perfectly matches the grammar rule you provided.
    def visitRaiseerror_statement(self, ctx: TSqlParser.Raiseerror_statementContext):
        msg = ctx.STRING().getText() if ctx.STRING() else "<no message>"
        stmt = {
            "type": "RAISERROR",
            "message": msg,
            "severity": ctx.constant_LOCAL_ID(0).getText(),
            "state": ctx.constant_LOCAL_ID(1).getText()
        }
        print(f"üö® RAISERROR: {stmt}")
        self._append_statement(stmt)

    def visitCursor_statement(self, ctx: TSqlParser.Cursor_statementContext):
        text = ctx.getText().upper()
        if ctx.DECLARE():
            cname = ctx.cursor_name().getText()
            select_ctx = ctx.declare_set_cursor_common().select_statement_standalone()
            sql = select_ctx.getText() if select_ctx else ""
            stmt = {
                "type": "DECLARE_CURSOR",
                "cursor_name": cname,
                "select": sql
            }
            print(f"üìç Declaring cursor: {stmt}")
        elif ctx.OPEN():
            stmt = {
                "type": "OPEN_CURSOR",
                "cursor_name": ctx.cursor_name().getText()
            }
            print(f"üìÇ Opening cursor: {stmt}")
        elif ctx.FETCH():
            stmt = {
                "type": "FETCH_CURSOR",
                "cursor_name": ctx.cursor_name().getText(),
                "fetch_into": [id.getText() for id in ctx.LOCAL_ID()]
            }
            print(f"üì• Fetching cursor: {stmt}")
        elif ctx.CLOSE():
            stmt = {
                "type": "CLOSE_CURSOR",
                "cursor_name": ctx.cursor_name().getText()
            }
            print(f"üì¥ Closing cursor: {stmt}")
        elif ctx.DEALLOCATE():
            stmt = {
                "type": "DEALLOCATE_CURSOR",
                "cursor_name": ctx.cursor_name().getText()
            }
            print(f"üóëÔ∏è Deallocating cursor: {stmt}")
        else:
            stmt = {"type": "UNKNOWN_CURSOR_STATEMENT", "text": ctx.getText()}

        self._append_statement(stmt)

    # CORRECTED: Fetch logic now correctly separates cursor name (id) from INTO vars (LOCAL_ID)
    def visitFetch_cursor(self, ctx):
        stmt = {
            "type": "FETCH_CURSOR",
            "cursor_name": self.get_full_text(ctx.id_()),
            "fetch_into": [self.get_full_text(id_) for id_ in ctx.LOCAL_ID()]
        }
        self._add_statement(stmt)

    # CORRECTED: Replaced manual iteration with direct ANTLR context access
    def visitDeclare_cursor(self, ctx):
        stmt = {
            "type": "DECLARE_CURSOR",
            "cursor_name": self.get_full_text(ctx.id_()),
            "query": self.get_full_text(ctx.select_statement())
        }
        self._add_statement(stmt)
        # We've processed this node completely, so stop further default traversal
        return None

def generate_ast(sql_file_path: str) -> list:
    with open(sql_file_path, "r") as f:
        input_sql = f.read()

    input_stream = InputStream(input_sql)
    lexer = TSqlLexer(input_stream)
    token_stream = CommonTokenStream(lexer)
    parser = TSqlParser(token_stream)
    print("üß† Parsing input SQL...")
    tree = parser.tsql_file()

    print("\nüå≥ Parse Tree:")
    print(tree.toStringTree(recog=parser))
    print()

    visitor = ASTBuilder()
    asts = visitor.visit(tree)

    if not asts:
        print("‚ùå No procedure AST found.")
    else:
        print(f"‚úÖ {len(asts)} procedure(s) parsed.")

    return asts

def save_ast(asts: list, output_path: str):
    print(f"üìù Writing ASTs to {output_path}")
    with open(output_path, "w") as f:
        json.dump(asts, f, indent=4)